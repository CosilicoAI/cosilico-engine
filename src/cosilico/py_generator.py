"""Python code generator for Cosilico DSL.

Compiles parsed DSL modules to vectorized Python code using NumPy.
The output is designed to work on arrays (not scalars) for efficient
batch computation.

The generated code produces identical results to the JS generator
for equivalent inputs.
"""

from dataclasses import dataclass, field
from typing import Optional

from .dsl_parser import (
    BinaryOp,
    Expression,
    FormulaBlock,
    FunctionCall,
    Identifier,
    IfExpr,
    LetBinding,
    Literal,
    MatchCase,
    MatchExpr,
    Module,
    ParameterRef,
    ReferencesBlock,
    UnaryOp,
    VariableDef,
    VariableRef,
)


# Operator mapping from DSL to Python (vectorized)
BINARY_OPS = {
    "+": "+",
    "-": "-",
    "*": "*",
    "/": "/",
    "%": "%",
    "<": "<",
    ">": ">",
    "<=": "<=",
    ">=": ">=",
    "==": "==",
    "!=": "!=",
    "and": "&",  # Bitwise for vectorized operations
    "or": "|",   # Bitwise for vectorized operations
}

UNARY_OPS = {
    "not": "~",  # Bitwise not for vectorized operations
    "-": "-",
}

# Built-in function mapping to NumPy equivalents
BUILTIN_FUNCTIONS = {
    "min": "np.minimum",
    "max": "np.maximum",
    "abs": "np.abs",
    "floor": "np.floor",
    "ceil": "np.ceil",
    "round": "np.round",
    "sqrt": "np.sqrt",
    "pow": "np.power",
}


@dataclass
class PyGenerator:
    """Generates Python code from parsed DSL modules."""

    indent: str = "    "
    _depth: int = field(default=0, init=False)
    _local_bindings: set = field(default_factory=set, init=False)

    def generate(self, module: Module) -> str:
        """Generate Python code for a module."""
        lines = []

        # Header comment and imports
        lines.append("# Generated by Cosilico Python Generator")
        lines.append("# Do not edit manually")
        lines.append("")
        lines.append("import numpy as np")
        lines.append("")

        # Generate each variable as a function
        for var in module.variables:
            lines.append(self._generate_variable(var, module.references))
            lines.append("")

        return "\n".join(lines)

    def _generate_variable(
        self, var: VariableDef, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate a function for a variable definition."""
        lines = []

        # Docstring
        if var.label or var.description:
            lines.append(f"def {var.name}(inputs, params):")
            lines.append(f'{self.indent}"""')
            if var.label:
                lines.append(f"{self.indent}{var.label}")
            if var.description:
                lines.append(f"{self.indent}{var.description}")
            if var.reference:
                lines.append(f"{self.indent}Reference: {var.reference}")
            lines.append(f'{self.indent}"""')
        else:
            lines.append(f"def {var.name}(inputs, params):")

        # Generate formula body
        if var.formula:
            body = self._generate_formula(var.formula, references)
            for line in body.split("\n"):
                lines.append(f"{self.indent}{line}")
        else:
            # No formula - return default
            default = var.default if var.default is not None else 0
            lines.append(f"{self.indent}return {self._format_literal(default)}")

        return "\n".join(lines)

    def _generate_formula(
        self, formula: FormulaBlock, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate code for a formula block."""
        lines = []

        # Clear local bindings for this formula
        self._local_bindings = set()

        # Generate let bindings
        for binding in formula.bindings:
            # Track the binding name as a local variable
            self._local_bindings.add(binding.name)
            value = self._generate_expression(binding.value, references)
            lines.append(f"{binding.name} = {value}")

        # Generate return expression
        if formula.return_expr:
            expr = self._generate_expression(formula.return_expr, references)
            lines.append(f"return {expr}")
        else:
            # Implicit return of last binding or default
            lines.append("return 0")

        return "\n".join(lines)

    def _generate_expression(
        self, expr: Expression, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate Python for an expression."""

        if isinstance(expr, Literal):
            return self._format_literal(expr.value)

        if isinstance(expr, Identifier):
            # Check if it's a local binding first
            if expr.name in self._local_bindings:
                return expr.name
            # Check if it's a reference alias
            if references and references.get_path(expr.name):
                # For now, just use the alias name as a variable
                return f"inputs['{expr.name}']"
            return f"inputs['{expr.name}']"

        if isinstance(expr, VariableRef):
            return f"{expr.name}(inputs, params)"

        if isinstance(expr, ParameterRef):
            if expr.index:
                return f"params['{expr.path}'][inputs['{expr.index}']]"
            return f"params['{expr.path}']"

        if isinstance(expr, BinaryOp):
            left = self._generate_expression(expr.left, references)
            right = self._generate_expression(expr.right, references)
            op = BINARY_OPS.get(expr.op, expr.op)

            # For logical operators, need parentheses
            if expr.op in ("and", "or"):
                return f"(({left}) {op} ({right}))"

            return f"({left} {op} {right})"

        if isinstance(expr, UnaryOp):
            operand = self._generate_expression(expr.operand, references)
            op = UNARY_OPS.get(expr.op, expr.op)
            return f"({op}({operand}))"

        if isinstance(expr, FunctionCall):
            args = [self._generate_expression(arg, references) for arg in expr.args]
            func_name = BUILTIN_FUNCTIONS.get(expr.name, expr.name)
            return f"{func_name}({', '.join(args)})"

        if isinstance(expr, IfExpr):
            cond = self._generate_expression(expr.condition, references)
            then = self._generate_expression(expr.then_branch, references)
            else_ = self._generate_expression(expr.else_branch, references)
            return f"np.where({cond}, {then}, {else_})"

        if isinstance(expr, MatchExpr):
            return self._generate_match(expr, references)

        if isinstance(expr, LetBinding):
            # Inline let bindings in expressions
            value = self._generate_expression(expr.value, references)
            return value

        # Fallback
        return f"0  # unknown expression: {type(expr).__name__}"

    def _generate_match(
        self, match: MatchExpr, references: Optional[ReferencesBlock]
    ) -> str:
        """Generate Python for a match expression.

        Converts to nested np.where calls.
        """
        # Build from inside out - start with else case
        result = None

        # Find the else case first
        for case in match.cases:
            if case.condition is None:
                result = self._generate_expression(case.value, references)
                break

        if result is None:
            result = "0"  # Default if no else case

        # Now wrap with conditions from last to first
        for case in reversed(match.cases):
            if case.condition is not None:
                cond = self._generate_expression(case.condition, references)
                value = self._generate_expression(case.value, references)
                result = f"np.where({cond}, {value}, {result})"

        return result

    def _format_literal(self, value) -> str:
        """Format a literal value as Python."""
        if value is True:
            return "True"
        if value is False:
            return "False"
        if value is None:
            return "None"
        if isinstance(value, str):
            # Escape quotes
            escaped = value.replace("\\", "\\\\").replace('"', '\\"')
            return f'"{escaped}"'
        if isinstance(value, (int, float)):
            return str(value)
        return str(value)


def generate_python(module: Module) -> str:
    """Generate Python code from a parsed DSL module.

    Args:
        module: Parsed DSL module

    Returns:
        Python source code as a string
    """
    generator = PyGenerator()
    return generator.generate(module)
